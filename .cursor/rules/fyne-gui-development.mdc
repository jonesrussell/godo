# Fyne GUI Development

This project uses Fyne v2.6.1 for cross-platform GUI development with specific patterns for thread safety and window management.

## Thread Safety (Fyne v2.6.0+)

### Single Goroutine Model
- **Since Fyne v2.6.0**: All Fyne events and callbacks happen on the same goroutine
- This provides higher performance and better thread safety than previous versions
- Applications using goroutines need explicit handling for UI updates

### UI Thread Operations
- **ALWAYS** wrap UI operations in `fyne.Do()` or `fyne.DoAndWait()`
- Use `fyne.Do()` for background updates (non-blocking, up to 15ms delay)
- Use `fyne.DoAndWait()` when you need to wait for UI update completion
- Never call Fyne UI methods directly from background goroutines

### When to Use Each Function

#### `fyne.Do()` - Non-blocking Updates
```go
// For background updates (e.g., timers, network responses)
go func() {
    ticker := time.NewTicker(time.Second)
    for range ticker.C {
        fyne.Do(func() {
            output.Text = time.Now().Format(time.TimeOnly)
            output.Refresh()
        })
    }
}()
```

#### `fyne.DoAndWait()` - Blocking Updates
```go
// When you need to wait for UI update completion
// Useful for avoiding concurrent access to shared resources
fyne.DoAndWait(func() {
    window := app.NewWindow("Title")
    window.SetContent(content)
    window.Show()
})
// Code here runs after UI update is complete
```

### Window Creation Pattern
```go
// For background thread calls (e.g., hotkey handlers)
func createWindowFromBackground() {
    var window fyne.Window
    fyne.DoAndWait(func() {
        window = app.NewWindow("Title")
        // ... setup window
    })
    // Window is now ready to use
}

// For UI thread calls (e.g., systray menu)
func createWindowFromUI() {
    fyne.Do(func() {
        window := app.NewWindow("Title")
        // ... setup window
    })
}
```

## Window Management

### Quick Note Window Pattern
- Use singleton pattern with mutex protection
- Implement proper lifecycle management
- Handle window recreation after close
- Use factory pattern for on-demand creation

### Window Focus
- **widget.Entry does NOT have a Focus() method** in Fyne API
- Use canvas.Focus() for programmatic focus:
```go
canvas := fyne.CurrentApp().Driver().CanvasForObject(entry)
if canvas != nil {
    canvas.Focus(entry)
}
```

## Custom Widget Development

### Embedding Fyne Widgets
- Always embed pointer types: `*widget.Entry`, not `widget.Entry`
- Explicitly forward methods that don't auto-promote:
```go
type CustomEntry struct {
    *widget.Entry
    // custom fields
}

// Forward methods that don't auto-promote
func (e *CustomEntry) Focus() {
    e.Entry.Focus() // Only if Entry has Focus method
}
```

### Widget Initialization
- Use `ExtendBaseWidget()` for custom widgets
- Set up event handlers in constructor
- Initialize embedded widgets properly

## Error Handling

### Thread Safety Errors
- Watch for "Error in Fyne call thread" messages
- Ensure all UI operations are on main thread
- Use proper synchronization for window creation

### Focus Issues
- Don't call `FocusGained()` manually (causes UI hangs)
- Use `canvas.Focus()` for programmatic focus
- Handle cases where canvas is nil

## Best Practices

### Window Creation
- Create windows on UI thread when possible
- Use explicit thread context parameters
- Implement proper cleanup and lifecycle

### Event Handling
- Keep event handlers lightweight
- Use goroutines for long-running operations
- Update UI state through `fyne.Do()`

### Resource Management
- Properly close windows and resources
- Handle window close events
- Clean up event handlers

### Performance Considerations
- `fyne.Do()` has up to 15ms delay before execution
- Use `fyne.DoAndWait()` when you need immediate completion
- Avoid blocking the UI thread with heavy operations

## Common Issues and Solutions

### "Not Responding" Windows
- Caused by UI operations on wrong thread
- Fix: Wrap in `fyne.Do()` or `fyne.DoAndWait()`
- Check for manual `FocusGained()` calls

### Missing Methods
- `widget.Entry` doesn't have `Focus()` method
- Use `canvas.Focus()` instead
- Check Fyne API documentation for available methods

### Thread Deadlocks
- Avoid calling `fyne.DoAndWait()` from UI thread
- Use explicit thread context detection
- Implement timeout mechanisms

### Performance Issues
- Don't use `fyne.DoAndWait()` for frequent updates
- Use `fyne.Do()` for background updates
- Batch UI updates when possible

## Testing
- Test window creation from different thread contexts
- Verify focus behavior
- Test window lifecycle (create, show, hide, close)
- Test thread safety with concurrent operations
- Test performance with frequent UI updates
description:
globs: ["**/gui/**/*.go", "**/quicknote/**/*.go", "**/mainwindow/**/*.go"]
alwaysApply: false
---
